"""
Perceptron simple con interfaz Tkinter y gráfica en tiempo real usando matplotlib.
Características:
- Carga de datasets CSV / JSON / Excel.
- Detección automática de entradas, salidas y patrones (intenta detectar columnas objetivo binarias).
- Configuración de pesos iniciales (aleatorios o manuales), umbral (bias), tasa de aprendizaje, max iteraciones y error tolerado.
- Algoritmo de entrenamiento: Regla Delta (corrección de error) con función de activación escalón.
- Condiciones de parada: max iteraciones o error promedio <= tolerancia.
- Visualización en tiempo real del error (RMS) por iteración.
- Prueba con patrones del dataset o patrones nuevos ingresados por el usuario.

Requerimientos:
- Python 3.8+
- pandas
- numpy
- matplotlib
- openpyxl (para xlsx)

Guardar este archivo como `perceptron_app.py` y ejecutar: python perceptron_app.py
"""

import threading
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg


class Perceptron:
    def __init__(self, n_inputs, n_outputs=1, weights=None, bias=None, lr=0.1):
        # Internally we keep bias as an extra weight (last column)
        self.n_inputs = n_inputs
        self.n_outputs = n_outputs
        if weights is None:
            # small random numbers
            self.weights = np.random.randn(n_outputs, n_inputs) * 0.01
        else:
            w = np.array(weights)
            if w.shape == (n_outputs, n_inputs):
                self.weights = w.copy()
            else:
                raise ValueError('weights must have shape (n_outputs, n_inputs)')
        if bias is None:
            self.bias = np.random.randn(n_outputs) * 0.01
        else:
            self.bias = np.array(bias)
            if self.bias.shape != (n_outputs,):
                raise ValueError('bias must have shape (n_outputs,)')
        self.lr = lr

    def activation(self, net):
        # step function: returns 1 for net >= 0, else 0
        return (net >= 0).astype(int)

    def predict(self, X):
        # X shape: (n_patterns, n_inputs)
        net = X.dot(self.weights.T) + self.bias
        return self.activation(net)

    def fit(self, X, T, max_iter=100, tol=1e-3, callback=None, stop_event=None):
        """Train using online delta rule (per-pattern updates).
        X: (n_patterns, n_inputs)
        T: (n_patterns, n_outputs) targets must be 0/1
        callback: function(iteration, rms) called each iteration (epoch)
        stop_event: threading.Event to allow stopping from UI
        Returns errors list (rms per iteration)
        """
        n_patterns = X.shape[0]
        errors = []
        for it in range(1, max_iter + 1):
            sq_err_sum = 0.0
            # Shuffle for online updates
            indices = np.arange(n_patterns)
            np.random.shuffle(indices)
            for idx in indices:
                x = X[idx]  # shape (n_inputs,)
                t = T[idx]  # shape (n_outputs,)
                net = np.dot(self.weights, x) + self.bias  # (n_outputs,)
                y = (net >= 0).astype(int)
                e = t - y  # error vector
                # update weights and bias: w += lr * e * x
                # broadcast properly
                self.weights += self.lr * np.outer(e, x)
                self.bias += self.lr * e
                sq_err_sum += np.sum(e ** 2)
                if stop_event and stop_event.is_set():
                    return errors
            # RMS per pattern (averaged over outputs too)
            rms = np.sqrt(sq_err_sum / (n_patterns * self.n_outputs))
            errors.append(rms)
            if callback:
                callback(it, rms)
            if rms <= tol:
                break
        return errors


class PerceptronApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('Perceptrón simple - Práctica')
        self.geometry('1100x700')
        self.dataset = None
        self.X = None
        self.T = None
        self.perceptron = None
        self.training_thread = None
        self.stop_event = threading.Event()
        self.errors = []
        self.create_widgets()

    def create_widgets(self):
        # Left frame: controles
        left = ttk.Frame(self)
        left.pack(side=tk.LEFT, fill=tk.Y, padx=8, pady=8)

        ttk.Label(left, text='Dataset').pack(anchor=tk.W)
        ttk.Button(left, text='Cargar dataset', command=self.load_dataset).pack(fill=tk.X)
        self.ds_info = tk.Text(left, width=40, height=8)
        self.ds_info.pack()

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(left, text='Parámetros iniciales').pack(anchor=tk.W)
        frm = ttk.Frame(left)
        frm.pack(fill=tk.X)

        ttk.Label(frm, text='Tasa aprendizaje (η)').grid(row=0, column=0, sticky=tk.W)
        self.lr_var = tk.DoubleVar(value=0.1)
        ttk.Entry(frm, textvariable=self.lr_var).grid(row=0, column=1)

        ttk.Label(frm, text='Max iteraciones').grid(row=1, column=0, sticky=tk.W)
        self.max_iter_var = tk.IntVar(value=100)
        ttk.Entry(frm, textvariable=self.max_iter_var).grid(row=1, column=1)

        ttk.Label(frm, text='Error tolerado (ϵ)').grid(row=2, column=0, sticky=tk.W)
        self.tol_var = tk.DoubleVar(value=0.01)
        ttk.Entry(frm, textvariable=self.tol_var).grid(row=2, column=1)

        ttk.Label(frm, text='Umbral / bias (coma sep)').grid(row=3, column=0, sticky=tk.W)
        self.bias_entry = ttk.Entry(frm)
        self.bias_entry.grid(row=3, column=1)
        ttk.Label(frm, text='Dejar vacío para aleatorio').grid(row=3, column=2)

        ttk.Label(frm, text='Pesos iniciales (fila por salida)').grid(row=4, column=0, sticky=tk.W)
        self.weights_entry = ttk.Entry(frm)
        self.weights_entry.grid(row=4, column=1)
        ttk.Label(frm, text='ej: "0.1,0.2; -0.1,0.3" para 2 salidas').grid(row=4, column=2)

        ttk.Button(left, text='Inicializar perceptrón', command=self.init_perceptron).pack(fill=tk.X, pady=4)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Button(left, text='Iniciar entrenamiento', command=self.start_training).pack(fill=tk.X)
        ttk.Button(left, text='Detener entrenamiento', command=self.stop_training).pack(fill=tk.X)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)

        ttk.Label(left, text='Simulación / Pruebas').pack(anchor=tk.W)
        ttk.Button(left, text='Probar patrón del dataset (aleatorio)', command=self.test_random_pattern).pack(fill=tk.X)

        ttk.Label(left, text='Ingresar nuevo patrón (coma sep)').pack(anchor=tk.W)
        self.new_pattern_entry = ttk.Entry(left)
        self.new_pattern_entry.pack(fill=tk.X)
        ttk.Button(left, text='Probar patrón nuevo', command=self.test_new_pattern).pack(fill=tk.X)

        ttk.Separator(left, orient=tk.HORIZONTAL).pack(fill=tk.X, pady=6)
        ttk.Button(left, text='Guardar pesos a CSV', command=self.save_weights).pack(fill=tk.X)

        # Right frame: gráfica y logs
        right = ttk.Frame(self)
        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # Matplotlib figure
        self.fig = Figure(figsize=(6, 4), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.ax.set_title('Evolución del error (RMS)')
        self.ax.set_xlabel('Iteración')
        self.ax.set_ylabel('RMS error')
        self.line, = self.ax.plot([], [])
        self.canvas = FigureCanvasTkAgg(self.fig, master=right)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Logs
        ttk.Label(right, text='Consola').pack(anchor=tk.W)
        self.log = tk.Text(right, height=10)
        self.log.pack(fill=tk.BOTH, expand=False)

    def log_msg(self, msg):
        self.log.insert(tk.END, msg + '\n')
        self.log.see(tk.END)

    def load_dataset(self):
        file = filedialog.askopenfilename(filetypes=[('CSV', '*.csv'), ('JSON', '*.json'), ('Excel', '*.xlsx;*.xls')])
        if not file:
            return
        try:
            if file.lower().endswith('.csv'):
                df = pd.read_csv(file)
            elif file.lower().endswith('.json'):
                df = pd.read_json(file)
            else:
                df = pd.read_excel(file)
        except Exception as e:
            messagebox.showerror('Error', f'No se pudo leer el archivo: {e}')
            return
        self.dataset = df
        n_rows, n_cols = df.shape
        # Detectar automáticamente columnas objetivo
        # Estrategia: columnas con pocos valores únicos (2) y valores {0,1} o {-1,1} serán consideradas salidas.
        candidate_outputs = []
        for col in df.columns:
            uniq = df[col].dropna().unique()
            if len(uniq) <= 2:
                # check if values are in {0,1} or {-1,1} or boolean-like
                setu = set(np.unique(uniq))
                if setu.issubset({0, 1}) or setu.issubset({-1, 1}) or setu.issubset({True, False}) or setu.issubset({'0','1'}):
                    candidate_outputs.append(col)
        if len(candidate_outputs) == 0:
            # fallback: last column is output
            outputs = [df.columns[-1]]
            self.log_msg('No se detectaron columnas binarias automáticamente. Tomando la última columna como salida: ' + str(outputs))
        else:
            outputs = candidate_outputs
            self.log_msg('Columnas detectadas como salida: ' + str(outputs))
        inputs = [c for c in df.columns if c not in outputs]
        self.ds_info.delete('1.0', tk.END)
        self.ds_info.insert(tk.END, f'Archivo: {file}\nFilas: {n_rows}\nColumnas: {n_cols}\nEntradas detectadas: {len(inputs)} -> {inputs}\nSalidas detectadas: {len(outputs)} -> {outputs}\n')
        # Convert to numeric and drop rows with NaN
        df2 = df.copy()
        for c in df2.columns:
            df2[c] = pd.to_numeric(df2[c], errors='coerce')
        df2 = df2.dropna()
        self.dataset = df2
        # Prepare X, T
        X = df2[inputs].values.astype(float)
        T = df2[outputs].values
        # Convert targets to 0/1
        T = np.where(T <= 0, 0, 1)
        self.X = X
        self.T = T
        self.log_msg('Dataset cargado y procesado. Patrones válidos: ' + str(self.X.shape[0]))

    def init_perceptron(self):
        if self.X is None:
            messagebox.showwarning('Atención', 'Primero cargue un dataset válido')
            return
        n_inputs = self.X.shape[1]
        n_outputs = 1 if self.T.ndim == 1 or self.T.shape[1] == 1 else self.T.shape[1]
        # Parse weights and bias if provided
        weights = None
        bias = None
        w_text = self.weights_entry.get().strip()
        if w_text:
            try:
                # rows separated by ;, numbers by ,
                rows = [r.strip() for r in w_text.split(';') if r.strip()]
                wmat = []
                for r in rows:
                    nums = [float(x) for x in r.split(',')]
                    if len(nums) != n_inputs:
                        raise ValueError('Cada fila de pesos debe tener ' + str(n_inputs) + ' valores')
                    wmat.append(nums)
                if len(wmat) == 1 and n_outputs > 1:
                    # broadcast
                    wmat = [wmat[0] for _ in range(n_outputs)]
                weights = np.array(wmat)
            except Exception as e:
                messagebox.showerror('Error pesos', str(e))
                return
        b_text = self.bias_entry.get().strip()
        if b_text:
            try:
                bvals = [float(x) for x in b_text.split(',') if x.strip()]
                if len(bvals) == 1 and (n_outputs > 1):
                    bvals = bvals * n_outputs
                if len(bvals) != n_outputs:
                    raise ValueError('Número de umbrales debe coincidir con salidas')
                bias = np.array(bvals)
            except Exception as e:
                messagebox.showerror('Error bias', str(e))
                return
        lr = float(self.lr_var.get())
        self.perceptron = Perceptron(n_inputs=n_inputs, n_outputs=n_outputs, weights=weights, bias=bias, lr=lr)
        self.log_msg(f'Perceptrón inicializado: entradas={n_inputs}, salidas={n_outputs}, lr={lr}')
        self.log_msg('Pesos iniciales:\n' + str(self.perceptron.weights))
        self.log_msg('Bias inicial:\n' + str(self.perceptron.bias))

    def update_plot(self):
        if not self.errors:
            return
        self.ax.cla()
        self.ax.set_title('Evolución del error (RMS)')
        self.ax.set_xlabel('Iteración')
        self.ax.set_ylabel('RMS error')
        iters = np.arange(1, len(self.errors) + 1)
        self.ax.plot(iters, self.errors)
        self.canvas.draw()

    def training_callback(self, it, rms):
        # called from training thread; use after to schedule on main thread
        def cb():
            self.errors.append(rms)
            self.log_msg(f'Iter {it} - RMS error: {rms:.6f}')
            self.update_plot()
        self.after(0, cb)

    def start_training(self):
        if self.perceptron is None:
            messagebox.showwarning('Atención', 'Inicialice el perceptrón primero')
            return
        if self.X is None or self.T is None:
            messagebox.showwarning('Atención', 'Cargue un dataset primero')
            return
        max_iter = int(self.max_iter_var.get())
        tol = float(self.tol_var.get())
        self.errors = []
        self.stop_event.clear()

        def run_train():
            try:
                self.log_msg('Entrenamiento iniciado...')
                errs = self.perceptron.fit(self.X, self.T if self.T.ndim>1 else self.T.reshape(-1,1),
                                          max_iter=max_iter, tol=tol,
                                          callback=self.training_callback, stop_event=self.stop_event)
                self.log_msg('Entrenamiento finalizado. Iteraciones: ' + str(len(errs)))
                self.log_msg('Pesos finales:\n' + str(self.perceptron.weights))
                self.log_msg('Bias final:\n' + str(self.perceptron.bias))
            except Exception as e:
                self.log_msg('Error durante entrenamiento: ' + str(e))

        self.training_thread = threading.Thread(target=run_train, daemon=True)
        self.training_thread.start()

    def stop_training(self):
        if self.training_thread and self.training_thread.is_alive():
            self.stop_event.set()
            self.log_msg('Se solicitó detener entrenamiento...')
        else:
            self.log_msg('No hay entrenamiento en curso')

    def test_random_pattern(self):
        if self.X is None:
            messagebox.showwarning('Atención', 'Cargue un dataset primero')
            return
        idx = np.random.randint(0, self.X.shape[0])
        x = self.X[idx]
        t = self.T[idx]
        out = self.perceptron.predict(x.reshape(1, -1)) if self.perceptron else None
        self.log_msg('Patrón índice: ' + str(idx))
        self.log_msg('Entrada: ' + str(x))
        self.log_msg('Salida esperada: ' + str(t))
        self.log_msg('Salida perceptrón: ' + str(out.tolist() if out is not None else 'Perceptrón no inicializado'))

    def test_new_pattern(self):
        txt = self.new_pattern_entry.get().strip()
        if not txt:
            messagebox.showwarning('Atención', 'Ingrese un patrón (valores separados por coma)')
            return
        try:
            nums = [float(x) for x in txt.split(',')]
        except:
            messagebox.showerror('Error', 'Formato inválido, use números separados por coma')
            return
        if self.perceptron is None:
            messagebox.showwarning('Atención', 'Inicialice el perceptrón primero')
            return
        if len(nums) != self.perceptron.n_inputs:
            messagebox.showerror('Error', f'La longitud del patrón debe ser {self.perceptron.n_inputs}')
            return
        x = np.array(nums).reshape(1, -1)
        out = self.perceptron.predict(x)
        self.log_msg('Entrada nueva: ' + str(nums))
        self.log_msg('Salida perceptrón: ' + str(out.tolist()))

    def save_weights(self):
        if self.perceptron is None:
            messagebox.showwarning('Atención', 'Inicialice el perceptrón primero')
            return
        file = filedialog.asksaveasfilename(defaultextension='.csv', filetypes=[('CSV','*.csv')])
        if not file:
            return
        try:
            # Save weights and bias as CSV: each row = weights...,bias
            rows = []
            for i in range(self.perceptron.n_outputs):
                row = list(self.perceptron.weights[i]) + [self.perceptron.bias[i]]
                rows.append(row)
            cols = [f'w{i}' for i in range(self.perceptron.n_inputs)] + ['bias']
            df = pd.DataFrame(rows, columns=cols)
            df.to_csv(file, index=False)
            self.log_msg('Pesos guardados en: ' + file)
        except Exception as e:
            messagebox.showerror('Error al guardar', str(e))


if __name__ == '__main__':
    app = PerceptronApp()
    app.mainloop()
